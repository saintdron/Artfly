<?php
require_once "Apache/LookupUri.php";

    // mod_php:
    //   OK call:
    //     a) /ok.html                   REDIRECT_STATUS!=''
    //   Direct calls:
    //     a) handler.php?/hacked.html   REDIRECT_STATUS=''
    //     b) handler.php/hacked.html    REDIRECT_STATUS=''
    // cgi_php:
    //   OK call:
    //     a) /ok.html                   REDIRECT_REDIRECT_STATUS
    //   Direct calls:
    //     a) handler.php?/hacked.html
    //     b) handler.php/hacked.html


class Apache_Rewriter {
  var $VERSION = "1.21";

  // Static function.
  // Return URL which was passed to the handler.
  // Support for these two Apache schemas:
  // 1. Action handler "/path/to/handler.php"
  //    Resulting URL: /path/to/handler.php/page.html 
  //    (URL passed via PATH_INFO)
  // 2. Action handler "/path/to/handler.php?"
  //    Resulting URL: /path/to/handler.php?/page.html 
  //    (URL passed via QUERY_STRING)
  // On hacking attempt - return null.
  function getOriginalUri(&$error)
  {
    $error = null;

    $context = "";
    $isModule = function_exists('apache_get_version');
    $mode = 'qs';
    if (isset($_SERVER['PATH_INFO']) && ($isModule || isset($_SERVER['ORIG_PATH_INFO']))) {
      // It is mod_php4 or PHP5 (cgi or module - no matter).
      $mode = "pi";
    }
    $script_name = $query_string = "";

    // Build RE matching current script name.
    $parts = array();
    $thisScript = $isModule? $_SERVER['SCRIPT_NAME'] : $_SERVER['REDIRECT_URL'];
    foreach (preg_split('{[/\\\\]}s', $thisScript) as $part) {
      if (!strlen($part)) continue;
      $parts[] = '([/\\\\]|^)' . preg_quote($part, '{}') . '(?=[/\\\\?&]|$)';
    }
    $re = '{^.*' . join('.*', $parts) . '}si';
    // Check REQUEST_URI for that RE. We need to use RE because of
    // hacks like REQUEST_URI = "../../../WEBINF/...".
    // It is dirty method, but - it works...
    if (preg_match($re, $_SERVER['REQUEST_URI'])) {
      $error = "Suspicious REQUEST_URI: contains path parts from SCRIPT_NAME";
      return null;
    }
//    echo "$re, $thisScript<br>";
//    echo "$mode: <pre>".print_r($_SERVER,1)."</pre>";

    // Starting from here security seems to be clean.
    // But we also make more checks below - in easy cases.
    
    if ($mode == "qs") {
      // URI passed via QUERY_STRING: handler.php?/a.html?a=b
      $context = "QUERY_STRING";
      $query_string = $_SERVER['QUERY_STRING'];
      $delim = '?';
      if (isset($_SERVER['SCRIPT_URL'])) {
        $context .= ":mod_rewrite";
        // mod_rewrite may corrupt "?" in URI:
        // QUERY_STRING: /a.html?a=b -> /a.html&a=b
        // So - use first & as delimiter in this case.
        if (preg_match('/^[^&?]*&/s', $query_string)) $delim = '&';
      } else {
        $context .= ":Action";
        // No mod_rewrite: Action used, QUERY_STRING is correct.
        // When no mod_rewrite used, QUERY_STRING ALWAYS equal to REQUEST_URI.
        if ($query_string !== $_SERVER['REQUEST_URI']) {
          $error = "$context: direct handler call: QUERY_STRING != REQUEST_URI";
          return null;
        }
      }
      @list ($script_name, $query_string) = explode($delim, $query_string, 2);
    } else {
      $context = "PATH_INFO";
      // Hacking attempt!
      if (!isset($_SERVER['REDIRECT_URL'])) {
        $error = "$context: direct handler call";
        return null;
      }
      // URI passed via PATH_INFO: handler.php/a.html?a=b
      $script_name = $_SERVER['PATH_INFO'];
      $query_string = $_SERVER['QUERY_STRING'];
    }

    // Build full request.
    $request = $script_name . (strlen($query_string) > 0? '?'.$query_string : '');

    return $request;
  }


  // Static function.
  // Changes all the global variables to the state if
  // they was generated by request $uri. This function is
  // used to "emulate" ModRewrite behavour.
  function doPseudoRedirect($uri, $useErrorIfNoFile=false)
  {
    if ($useErrorIfNoFile === true) $useErrorIfNoFile = "404";

    // When mod_rewrite is active, we shoild NOT lookupe RELATIVE 
    // urls (apache bug?). Then always lookup absolute urls.
    if ($uri && $uri[0]!='/') {
      $dir = dirname($_SERVER['SCRIPT_NAME']);
      if (!$dir || $dir == "/" || $dir == "\\") $dir = "";
      $uri = "$dir/$uri";
    }
    $info = apache_lookup_uri($uri);

    $_SERVER["REDIRECT_URL"] = $info->uri;
    $_SERVER["PATH_TRANSLATED"] = $info->filename;
    $_SERVER["ORIG_REQUEST_URI"] = $_SERVER["REQUEST_URI"];
    $_SERVER["REQUEST_URI"] = $info->unparsed_uri;
    $_SERVER["QUERY_STRING"] = isset($info->args)? $info->args : '';
    $_GET = array(); parse_str($_SERVER["QUERY_STRING"], $_GET);

    if (ini_get("register_globals")) $GLOBALS += $_GET;
    if (isset($_REQUEST)) $_REQUEST += $_GET;
    if (isset($GLOBALS["HTTP_GET_VARS"])) $GLOBALS["HTTP_GET_VARS"] = $_GET;
    if (isset($_SERVER['argv'])) {
      $_SERVER['argv'] = explode("+", $_SERVER["QUERY_STRING"]);
      $_SERVER['argc'] = count($_SERVER['argv']);
    }
    Apache_Rewriter::_correctVars($GLOBALS, array(
      "argc" => "argc",
      "argv" => "argv",
      "QUERY_STRING" => "QUERY_STRING",
      "REQUEST_URI" => "REQUEST_URI",
      "PHP_SELF" => "REDIRECT_URL",
      "SCRIPT_NAME" => "REDIRECT_URL",
      "SCRIPT_FILENAME" => "PATH_TRANSLATED",
    ));
#   echo "{$_SERVER['SCRIPT_NAME']} - {$_SERVER['REDIRECT_URL']}";
    
    if ($useErrorIfNoFile) {
      if (!file_exists($_SERVER['PATH_TRANSLATED'])) {
        Apache_Rewriter::doErrorDocument($useErrorIfNoFile);
      }
    }

    chdir(dirname($_SERVER['PATH_TRANSLATED']));
  }


  // Static function.
  // Generates the ErrorDocument request.
  // Can be used to drop to the error page any time.
  function doErrorDocument($err=404)
  {
    # Search down for .htaccess-es.
    $h = false;
    for ($path=getcwd(); strlen($path) >= strlen($_SERVER["DOCUMENT_ROOT"]); $path=dirname($path)) {
      $file = @file("$path/.htaccess"); if (!$file) continue;
      foreach ($file as $s) {
        if (!preg_match('/^\\s*ErrorDocument\\s+'.$err.'\\s+(.*)/is', $s, $p)) continue;
        $h = trim($p[1]);
        $h = preg_replace('/^"(.*)"$/s', '$1', $h);
        break(2);
      }
    }
    if ($h !== false) {
      putenv('VIRTUAL_REQUEST_URI='.$h); // stupid virtual() does not modify REQUEST_URI in child request!
      virtual($h);
    } else {
      $msg = "not found";
      if ($err == 404) $msg = "not found";
      if ($err == 403) $msg = "forbidden";
      if ($err == 500) $msg = "pained";
      header("Status: $err");
      echo "<html><head><title>$err ".ucwords($msg)."</title></head>";
      echo "<body><h1>".ucwords($msg)."</h1>The requested URL <tt>".htmlspecialchars(getenv("REQUEST_URI"))."</tt> was $msg on this server.";
      echo "<p><hr>".getenv("SERVER_SIGNATURE")."</body>";
#     phpinfo();
    }
    exit;
  }

  
  function _correctVars(&$arr, $map, $level=0)
  {
    if (!$level) foreach ($map as $k => $v) putenv("$k=".$_SERVER[$v]);
    foreach ($arr as $k => $v) {
      if ($k == "GLOBALS") continue;
      if (isset($map[$k])) {
        $arr[$k] = $_SERVER[$map[$k]];
      } elseif ($level < 3 && is_array($arr[$k])) {
        Apache_Rewriter::_correctVars($arr[$k], $map, $level+1);
        continue;
      }
    }
    // Seems foreach sets current array position to the last element...
    reset($arr);
  }
}
?>